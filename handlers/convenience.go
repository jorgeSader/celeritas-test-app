package handlers

import (
	"context"
	"fmt"
	"net/http"

	"github.com/jorgeSader/celeritas"
)

// renderGo renders a Go template page.
func (h *Handlers) renderGo(w http.ResponseWriter, r *http.Request, tmpl string, args ...interface{}) error {
	var data interface{}
	if len(args) > 0 {
		data = args[0] // First arg is data, if provided
	}
	return h.App.Render.GoPage(w, r, tmpl, data)
}

// renderJet renders a Jet template page.
// args[0] is data, args[1] is variables; both default to nil if omitted.
func (h *Handlers) renderJet(w http.ResponseWriter, r *http.Request, tmpl string, args ...interface{}) error {
	var data, variables interface{}
	if len(args) > 0 {
		data = args[0] // First arg is data
	}
	if len(args) > 1 {
		variables = args[1] // Second arg is variables
	}
	return h.App.Render.JetPage(w, r, tmpl, variables, data)
}

// render is a convenience function that renders a page using the configured renderer.
// args[0] is data, args[1] is variables; both default to nil if omitted.
func (h *Handlers) render(w http.ResponseWriter, r *http.Request, tmpl string, args ...interface{}) error {
	var data, variables interface{}
	if len(args) > 0 {
		data = args[0] // First arg is data
	}
	if len(args) > 1 {
		variables = args[1] // Second arg is variables
	}
	switch h.App.Render.Renderer {
	case "go":
		return h.App.Render.GoPage(w, r, tmpl, data)
	case "jet":
		return h.App.Render.JetPage(w, r, tmpl, data, variables)
	default:
		return fmt.Errorf("unknown renderer type: %s", h.App.Render.Renderer)
	}
}

// sessionPut stores a key-value pair in the session.
// The parameter ctx provides the context for the session operation.
// The parameter key is the identifier for the value, and val is the value to store.
// It delegates to the underlying App.Session.Put method.
func (h *Handlers) sessionPut(ctx context.Context, key string, val interface{}) {
	h.App.Session.Put(ctx, key, val)
}

// sessionHas checks if a key exists in the session.
// The parameter ctx provides the context for the session operation.
// The parameter key is the identifier to check.
// It returns true if the key exists, false otherwise, using App.Session.Exists.
func (h *Handlers) sessionHas(ctx context.Context, key string) bool {
	return h.App.Session.Exists(ctx, key)
}

// sessionGet retrieves a value from the session by its key.
// The parameter ctx provides the context for the session operation.
// The parameter key is the identifier of the value to retrieve.
// It returns the value associated with the key as an interface{}, or nil if not found, using App.Session.Get.
func (h *Handlers) sessionGet(ctx context.Context, key string) interface{} {
	return h.App.Session.Get(ctx, key)
}

// sessionRemove deletes a key-value pair from the session.
// The parameter ctx provides the context for the session operation.
// The parameter key is the identifier of the value to remove.
// It delegates to the underlying App.Session.Remove method.
func (h *Handlers) sessionRemove(ctx context.Context, key string) {
	h.App.Session.Remove(ctx, key)
}

// sessionRenew renews the session token.
// The parameter ctx provides the context for the session operation.
// The parameter key is unused but included for consistency with other session methods.
// It returns an error if the renewal fails, or nil on success, using App.Session.RenewToken.
func (h *Handlers) sessionRenew(ctx context.Context, key string) error {
	return h.App.Session.RenewToken(ctx)
}

// sessionDestroy terminates the session.
// The parameter ctx provides the context for the session operation.
// The parameter key is unused but included for consistency with other session methods.
// It returns an error if the destruction fails, or nil on success, using App.Session.Destroy.
func (h *Handlers) sessionDestroy(ctx context.Context, key string) error {
	return h.App.Session.Destroy(ctx)
}

// randomString generates a random string of the specified length.
// The parameter n specifies the desired length of the output string.
// It returns a random string generated by the underlying App.RandomString method.
func (h *Handlers) randomString(n int) string {
	return h.App.RandomString(n)
}

// encrypt encrypts the given text using the handler's encryption key.
// The parameter text is the plaintext to encrypt.
// It returns the encrypted text as a base64-encoded string and an error if encryption fails.
// It uses the celeritas.Encryption type with the handler's App.EncryptionKey.
func (h *Handlers) encrypt(text string) (string, error) {
	enc := celeritas.Encryption{Key: []byte(h.App.EncryptionKey)}

	encrypted, err := enc.Encrypt(text)
	if err != nil {
		return "", err
	}
	return encrypted, nil
}

// decrypt decrypts the given base64-encoded ciphertext using the handler's encryption key.
// The parameter crypto is the encrypted text to decrypt.
// It returns the decrypted plaintext string and an error if decryption fails.
// It uses the celeritas.Encryption type with the handler's App.EncryptionKey.
func (h *Handlers) decrypt(crypto string) (string, error) {
	enc := celeritas.Encryption{Key: []byte(h.App.EncryptionKey)}

	decrypted, err := enc.Decrypt(crypto)
	if err != nil {
		return "", err
	}
	return decrypted, nil
}
